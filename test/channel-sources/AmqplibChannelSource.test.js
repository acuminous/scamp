const { strictEqual: eq, rejects } = require('assert');
const { AmqplibChannelSource, ScampEvent, StickyConnectionSource, StubConnectionSource, Counter } = require('../..');

describe('AmqplibChannelSource', () => {

  let connectionSource;

  beforeEach(() => {
    connectionSource = new StubConnectionSource({ baseId: 'cs' });
    Counter.getInstance().clear();
  });

  describe('registerChannelListener', () => {

    it('should add registered listeners to new regular channels', async() => {
      let events = 0;
      const channelSource = new AmqplibChannelSource({ connectionSource });
      channelSource.registerChannelListener('close', () => events++ );

      const channel = await channelSource.getChannel();
      channel.emit('close');

      eq(events, 1);
    });

    it('should add registered listeners to new confirm channels', async() => {
      let events = 0;
      const channelSource = new AmqplibChannelSource({ connectionSource });
      channelSource.registerChannelListener('close', () => events++ );

      const channel = await channelSource.getConfirmChannel();
      channel.emit('close');

      eq(events, 1);
    });
  });

  describe('getChannel', () => {

    it('should decorate regular channels with x_scamp.id', async () => {
      const channelSource = new AmqplibChannelSource({ connectionSource });

      const channel = await channelSource.getChannel();
      eq(channel.x_scamp.id, 'cs#1-1-r');
    });

    it('should decorate confirm channels with x_scamp.id', async () => {
      const channelSource = new AmqplibChannelSource({ connectionSource });

      const channel = await channelSource.getConfirmChannel();
      eq(channel.x_scamp.id, 'cs#1-1-c');
    });

    it('should assign incremental x_scamp.id when generated by the same connection', async () => {
      const stickyConnectionSource = new StickyConnectionSource({ connectionSource });
      const channelSource = new AmqplibChannelSource({ connectionSource: stickyConnectionSource });

      const channel1 = await channelSource.getChannel();
      eq(channel1.x_scamp.id, 'cs#1-1-r');

      const channel2 = await channelSource.getConfirmChannel();
      eq(channel2.x_scamp.id, 'cs#1-2-c');
    });

    it('should restart x_scamp.id when generated by a new connection', async () => {
      const channelSource = new AmqplibChannelSource({ connectionSource });

      const channel1 = await channelSource.getChannel();
      eq(channel1.x_scamp.id, 'cs#1-1-r');

      const channel2 = await channelSource.getConfirmChannel();
      eq(channel2.x_scamp.id, 'cs#2-1-c');
    });
  });

  describe('Lost Channels', () => {

    it('should emit a lost event on channel close', async () => {
      let events = 0;
      const channelSource = new AmqplibChannelSource({ connectionSource });
      const channel = await channelSource.getChannel();
      channel.on(ScampEvent.LOST, () => events++);

      channel.emit('close');

      eq(events, 1);
    });

    it('should emit a lost event on connection error', async () => {
      let events = 0;
      const channelSource = new AmqplibChannelSource({ connectionSource });
      const channel = await channelSource.getChannel();
      channel.on(ScampEvent.LOST, () => events++);

      channel.emit('error');

      eq(events, 1);
    });

    it('should not emit a lost event when the channel source is closed', async () => {
      let events = 0;
      const channelSource = new AmqplibChannelSource({ connectionSource });
      const channel = await channelSource.getChannel();
      channel.on(ScampEvent.LOST, () => events++);
      await channelSource.close();

      channel.emit('close');

      eq(events, 0);
    });

    it('should only emit one lost event', async () => {
      let events = 0;
      const channelSource = new AmqplibChannelSource({ connectionSource });
      const channel = await channelSource.getChannel();
      channel.on(ScampEvent.LOST, () => events++);
      channel.on('error', () => {});

      channel.emit('error', new Error('Oh Noes'));
      channel.emit('error', new Error('Oh Noes'));
      channel.emit('close');
      channel.emit('close');

      eq(events, 1);
    });
  });

  describe('close', async () => {

    it('should reject attempts to get a regular channel when closed', async () => {
      const channelSource = new AmqplibChannelSource({ connectionSource });
      await channelSource.close();

      await rejects(() => channelSource.getChannel(), /The channel source is closed/);
    });

    it('should reject attempts to get a confirm channel when closed', async () => {
      const channelSource = new AmqplibChannelSource({ connectionSource });
      await channelSource.close();

      await rejects(() => channelSource.getConfirmChannel(), /The channel source is closed/);
    });

    it('should tolerate repeated closures', async () => {
      const channelSource = new AmqplibChannelSource({ connectionSource });
      await channelSource.close();
      await channelSource.close();
    });
  });
});
